################################################
依赖注入
有如下两种方式
//构造方法依赖注入，初始化A的时候才指明使用哪个B对象
public class A {
    B b;
    public void A(B b) {
        this.b = b;
    }
}

//set()方法依赖注入，初始化A后，再通过set方法，将需要的B对象赋值
public class A {
    B b;
    public void setB(B b) {
        this.b = b;
    }
}


  
################################################
Dagger
https://github.com/Ansonhrj/Dagger2c

1 使用 https://zhuanlan.zhihu.com/p/32772661
在例子中，MainPresenter是要注入的类(依赖类)，MainActivity是使用的地方（目标类，里面的mainPresenter变量叫目标对象）
@Inject注解会用在step 1 和3
1）MainPresenter的构造函数用 @Inject 注解
    class MainPresenter @Inject constructor() 
2）定义 Interface MainComponent, 作用是桥接MainPresenter 和MainActivity
    Interface 用@Componnet注解
    定义inject方法, 参数为MainActivity
         fun inject(mainActivity: MainActivity)
    重新编译代码，会自动生成DaggerMainComponent
3) 在MainActivity中实现注入
    用lateinit声明变量，并用@Inject注解
        lateinit var mainPresenter: MainPresenter
    调用自动生成的DaggerMainComponent实现注入
        DaggerMainComponent.builder().build().inject(this)
 
 2 假如依赖类是一个接口，或者在第三方library，就无法在它的构造函数加 @Inject
 https://zhuanlan.zhihu.com/p/36537962
 在例子中，MainService 是interface，MainSeviceImpl实现了这个接口。 
 1)创建一个MainServiceModule 类， 用@Module 注解， 这个类是MainServiceImpl的工厂类
 2）定义一个ProvideMainService方法，用于生成MainServiceImpl 的实例。这个方法用@Provides 注解。 @Module和@Provides是成队出现的
 @Module
class MainServiceModule {
    @Provides
    fun provideMainService(): MainService {
        return MainServiceImpl()   //这里是直接通过构造函数实例化
    }
}
 3）还是通过Component类将Module和MainActity桥接在一起。 注解要说明Module的class
 @Component(modules = [(MainServiceModule::class)])
 4）在MainActity调用注入的时候， 多调用了module的方法
 DaggerMainServiceComponent.builder().mainServiceModule(MainServiceModule()).build().inject(this)
       
3 在第2步中Module直接通过构造函数实例化，没有用Dagger。可以改成用Dagger递归注入
    return MainServiceImpl()   //这里是直接通过构造函数实例化 
 1）MainServiceImpl类要用@Inject注解构造函数。 这就告诉编译器，Dagger2可以注入的类型为MainServiceImpl的变量
 class MainServiceImpl @Inject constructor(): MainService {
 2）在Module中传入MainServiceImpl类型的参数
 fun provideMainService(mainService:MainServiceImpl):MainService{    //这个方法返回的是MainService类，因为目标对象是这个类型
        return mainService
    }

4 如果一个类既有@Inject构造方法，也有@Module工厂创建，@Module工厂的方式优先级高于@Inject构造方法
？？既然MainSerivceImpl都已经有@Inject注解的构造函数，直接在MainActivity 里面，像第一步那样注入就好了么？

5 Componnet组织架构
https://zhuanlan.zhihu.com/p/36538398
那从上至下，Component就会被划分为：
ApplicationComponent（Application级别，管理App全局实例）
ActivityComponent（Activity级别，管理Activity通用实例，Fragment同理）
业务Component（业务层面，根据具体业务划分）

6 Component服务能力
1）在Component中，还可以定义一个方法生成object，用于提供服务能力，供业务组件使用
@Component(modules = [(ApplicationModule::class)])
    interface ApplicationComponent {

        fun context():Context
    }








