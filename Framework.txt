################################################
依赖注入
有如下两种方式
//构造方法依赖注入，初始化A的时候才指明使用哪个B对象
public class A {
    B b;
    public void A(B b) {
        this.b = b;
    }
}

//set()方法依赖注入，初始化A后，再通过set方法，将需要的B对象赋值
public class A {
    B b;
    public void setB(B b) {
        this.b = b;
    }
}


  
################################################
Dagger
https://github.com/Ansonhrj/Dagger2SubComponent
https://www.imooc.com/article/22846

1 使用 https://zhuanlan.zhihu.com/p/32772661
在例子中，MainPresenter是要注入的类(依赖类)，MainActivity是使用的地方（目标类，里面的mainPresenter变量叫目标对象）
@Inject注解会用在step 1 和3
1）MainPresenter的构造函数用 @Inject 注解
    class MainPresenter @Inject constructor() 
2）定义 Interface MainComponent, 作用是桥接MainPresenter 和MainActivity
    Interface 用@Componnet注解
    定义inject方法, 参数为MainActivity
         fun inject(mainActivity: MainActivity)
    重新编译代码，会自动生成DaggerMainComponent
3) 在MainActivity中实现注入
    用lateinit声明变量，并用@Inject注解
        lateinit var mainPresenter: MainPresenter
    调用自动生成的DaggerMainComponent实现注入
        DaggerMainComponent.builder().build().inject(this)
 
 2 假如依赖类是一个接口，或者在第三方library，就无法在它的构造函数加 @Inject
 https://zhuanlan.zhihu.com/p/36537962
 在例子中，MainService 是interface，MainSeviceImpl实现了这个接口。 
 1)创建一个MainServiceModule 类， 用@Module 注解， 这个类是MainServiceImpl的工厂类
 2）定义一个ProvideMainService方法，用于生成MainServiceImpl 的实例。这个方法用@Provides 注解。 @Module和@Provides是成队出现的
 @Module
class MainServiceModule {
    @Provides
    fun provideMainService(): MainService {
        return MainServiceImpl()   //这里是直接通过构造函数实例化
    }
}
 3）还是通过Component类将Module和MainActity桥接在一起。 注解要说明Module的class
 @Component(modules = [(MainServiceModule::class)])
 4）在MainActity调用注入的时候， 
 多调用了module的方法,因为要首先创造工厂的实例，才可以生成目标对象
 .build()方法最终也是创造DaggerMainServiceComponent的实例，然后调用DaggerMainServiceComponent的inject方法去注入
 DaggerMainServiceComponent.builder().mainServiceModule(MainServiceModule()).build().inject(this)
       
3 在第2步中Module直接通过构造函数实例化，没有用Dagger。可以改成用Dagger递归注入
    return MainServiceImpl()   //这里是直接通过构造函数实例化 
 1）MainServiceImpl类要用@Inject注解构造函数。 这就告诉编译器，Dagger2可以注入的类型为MainServiceImpl的变量
 class MainServiceImpl @Inject constructor(): MainService {
 2）在Module中传入MainServiceImpl类型的参数
 fun provideMainService(mainService:MainServiceImpl):MainService{    //这个方法返回的是MainService类，因为目标对象是这个类型
        return mainService
    }

4 如果一个类既有@Inject构造方法，也有@Module工厂创建，@Module工厂的方式优先级高于@Inject构造方法
？？既然MainSerivceImpl都已经有@Inject注解的构造函数，直接在MainActivity 里面，像第一步那样注入就好了么？

5 Componnet组织架构
https://zhuanlan.zhihu.com/p/36538398
那从上至下，Component就会被划分为：
ApplicationComponent（Application级别，管理App全局实例）
ActivityComponent（Activity级别，管理Activity通用实例，Fragment同理）
业务Component（业务层面，根据具体业务划分）

6 Component服务能力
1）在Component中，还可以定义一个方法生成object，用于提供服务能力，供业务组件使用
@Component(modules = [(ApplicationModule::class)])
    interface ApplicationComponent {

        fun context():Context
    }

7 @Component.Builder， @BindsInstance 
https://juejin.im/post/5a4cf2b2f265da430d586ace
这个注解是用了自定义Dagger***Componnet中的内部类 Builder
总结：
如果使用 @Component.Builder 和 @BindsInstance 来自定义 Builder 类，那么被@BindsInstance注解方法里面的参数在 Builder 类中都有对应的成员变量。
    @BindsInstance Builder application(Application application);  //生成的Builder类中会有成员变量application
可以通过 Builder 类中的成员变量在 Component 中生成对应的 Provider<T> **Provider 成员，通过 **Provider 成员的get()就可以拿到依赖的实例了。
    ??

使用场景：
如果我们的 Moudle 某个被 @Provides 注解的 provide**(xxx obj) 函数使用了某种类型的对象作为参数(比如 application)，
    @Provides
    @Singleton
    public SharedPreferences providePreferences(Application application) 
而这个参数如果不想通过 Moudle 构造函数传递进来，那么就可以使用 @Component.Builder 来自定义 Builder 类，并通过 @BindsInstance 注解的方法来提供这个参数 obj。
 public Builder application(Application application) {//这是通过@BindsInstance生成的在Builder中的方法
      this.application = Preconditions.checkNotNull(application);
      return this;
 }
 
 注入时的区别
 没有使用@Component.Builder
 AppComponent appComponent = DaggerAppComponent.builder()
             .appMoudle(new AppMoudle(this))
             .build();
 使用了@Component.Builder
 DaggerAppComponent appComponent = DaggerAppComponent.builder()
           .application(this)
           .build();
或者直接给 Component 直接添加一个对象依赖的提供函数。
    ？？

################################################
Dagger-android
https://juejin.im/post/5b78d349f265da437c432db0
https://github.com/Ansonhrj/MVVM-Android-dagger-android.git
和普通的dagger对比一下区别就在于:
Dagger-Android在刚开始的时候通过注解处理器分析@Component、@Module、@ContributesAndroidInjector 等等注解，帮我们在App启动的时候建立了一个全局的单例map，并添加相关的映射。
这个map对象由App的dispatchingAndroidInjector对象持有。其中key值为activity/fragment的class，value为提供相应Component的Provider对象。







